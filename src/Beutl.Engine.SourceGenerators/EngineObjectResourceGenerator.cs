// <auto-generated/>
#nullable enable

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Beutl.Engine.SourceGenerators;

[Generator]
public sealed class EngineObjectResourceGenerator : IIncrementalGenerator
{
    private static readonly DiagnosticDescriptor s_missingPartialDiagnostic = new(
        id: "BESG001",
        title: "Partial declaration required",
        messageFormat: "Type '{0}' must be declared partial to generate Resource nested classes.",
        category: "Beutl.Engine.SourceGenerators",
        defaultSeverity: DiagnosticSeverity.Warning,
        isEnabledByDefault: true);

    private static readonly SymbolDisplayFormat s_typeDisplayFormat = new(
        globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Included,
        typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
        genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
        miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes
            | SymbolDisplayMiscellaneousOptions.EscapeKeywordIdentifiers
            | SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classDeclarations = context.SyntaxProvider.CreateSyntaxProvider(
                static (node, _) => node is ClassDeclarationSyntax { BaseList: not null },
                static (syntaxContext, cancellationToken) => GetClassInfo(syntaxContext, cancellationToken))
            .Where(static info => info is not null)
            .Select(static (info, _) => info!.Value);

        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

        context.RegisterSourceOutput(compilationAndClasses, static (productionContext, pair) =>
            Execute(productionContext, pair.Left, pair.Right));
    }

    private static ClassInfo? GetClassInfo(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        if (context.Node is not ClassDeclarationSyntax classDeclaration)
        {
            return null;
        }

        if (context.SemanticModel.GetDeclaredSymbol(classDeclaration, cancellationToken) is not INamedTypeSymbol symbol)
        {
            return null;
        }

        Compilation compilation = context.SemanticModel.Compilation;
        INamedTypeSymbol? engineObjectSymbol = compilation.GetTypeByMetadataName("Beutl.Engine.EngineObject");
        INamedTypeSymbol? iPropertySymbol = compilation.GetTypeByMetadataName("Beutl.Engine.IProperty`1");
        INamedTypeSymbol? suppressAttribute = compilation.GetTypeByMetadataName("Beutl.Engine.SuppressResourceClassGenerationAttribute");
        if (engineObjectSymbol is null || iPropertySymbol is null || suppressAttribute is null)
        {
            return null;
        }

        if (SymbolEqualityComparer.Default.Equals(symbol, engineObjectSymbol))
        {
            return null;
        }

        if (!InheritsFrom(symbol, engineObjectSymbol))
        {
            return null;
        }

        if (HasSuppressResourceClassGenerationAttribute(symbol, suppressAttribute))
        {
            return null;
        }

        bool isPartial = classDeclaration.Modifiers.Any(m => m.IsKind(Microsoft.CodeAnalysis.CSharp.SyntaxKind.PartialKeyword));

        var valueProperties = ImmutableArray.CreateBuilder<ValuePropertyInfo>();
        var objectProperties = ImmutableArray.CreateBuilder<ObjectPropertyInfo>();
        var listProperties = ImmutableArray.CreateBuilder<ListPropertyInfo>();

        foreach (ISymbol member in symbol.GetMembers())
        {
            if (member is not IPropertySymbol propertySymbol)
            {
                continue;
            }

            if (!SymbolEqualityComparer.Default.Equals(propertySymbol.ContainingType, symbol))
            {
                continue;
            }

            if (propertySymbol.IsStatic)
            {
                continue;
            }

            if (propertySymbol.Type is not INamedTypeSymbol namedType)
            {
                continue;
            }

            if (propertySymbol.GetAttributes().Any(attr => SymbolEqualityComparer.Default.Equals(attr.AttributeClass, suppressAttribute)))
            {
                continue;
            }

            if (namedType.IsGenericType && SymbolEqualityComparer.Default.Equals(namedType.ConstructedFrom, iPropertySymbol))
            {
                ITypeSymbol valueType = namedType.TypeArguments[0];
                if (IsEngineObjectType(valueType, engineObjectSymbol) && valueType is INamedTypeSymbol engineObjectType)
                {
                    objectProperties.Add(new ObjectPropertyInfo(propertySymbol.Name, engineObjectType));
                }
                else
                {
                    valueProperties.Add(new ValuePropertyInfo(propertySymbol.Name, valueType));
                }

                continue;
            }

            if (TryGetListElementType(namedType, engineObjectSymbol, out INamedTypeSymbol? elementType))
            {
                listProperties.Add(new ListPropertyInfo(propertySymbol.Name, elementType!));
            }
        }

        INamedTypeSymbol? baseResourceOwner = null;
        if (symbol.BaseType is INamedTypeSymbol baseType
            && InheritsFrom(baseType, engineObjectSymbol))
        {
            baseResourceOwner = baseType;
        }

        return new ClassInfo(
            symbol,
            isPartial,
            baseResourceOwner,
            valueProperties.ToImmutable(),
            objectProperties.ToImmutable(),
            listProperties.ToImmutable());
    }

    private static bool InheritsFrom(INamedTypeSymbol symbol, INamedTypeSymbol baseSymbol)
    {
        for (INamedTypeSymbol? current = symbol.BaseType; current is not null; current = current.BaseType)
        {
            if (SymbolEqualityComparer.Default.Equals(current, baseSymbol))
            {
                return true;
            }
        }

        return false;
    }

    private static bool IsEngineObjectType(ITypeSymbol type, INamedTypeSymbol engineObjectSymbol)
    {
        if (type is INamedTypeSymbol named)
        {
            if (SymbolEqualityComparer.Default.Equals(named, engineObjectSymbol))
            {
                return true;
            }

            return InheritsFrom(named, engineObjectSymbol);
        }

        return false;
    }

    private static bool IsListLike(INamedTypeSymbol type)
    {
        if (type.Name.EndsWith("List", StringComparison.Ordinal))
        {
            return true;
        }

        foreach (INamedTypeSymbol interfaceType in type.AllInterfaces)
        {
            if (interfaceType.Name.EndsWith("List", StringComparison.Ordinal))
            {
                return true;
            }
        }

        return false;
    }

    private static bool TryGetListElementType(INamedTypeSymbol type, INamedTypeSymbol engineObjectSymbol, out INamedTypeSymbol? elementType)
    {
        elementType = null;

        // Check if the type directly has a generic argument
        if (IsListLike(type) && type.TypeArguments.Length == 1 && type.TypeArguments[0] is INamedTypeSymbol directElementType)
        {
            if (IsEngineObjectType(directElementType, engineObjectSymbol))
            {
                elementType = directElementType;
                return true;
            }
        }

        // Search in base classes
        for (INamedTypeSymbol? current = type.BaseType; current is not null; current = current.BaseType)
        {
            if (IsListLike(current) && current.TypeArguments.Length == 1 && current.TypeArguments[0] is INamedTypeSymbol baseElementType)
            {
                if (IsEngineObjectType(baseElementType, engineObjectSymbol))
                {
                    elementType = baseElementType;
                    return true;
                }
            }
        }

        // Search in interfaces
        foreach (INamedTypeSymbol interfaceType in type.AllInterfaces)
        {
            if (IsListLike(interfaceType) && interfaceType.TypeArguments.Length == 1 && interfaceType.TypeArguments[0] is INamedTypeSymbol interfaceElementType)
            {
                if (IsEngineObjectType(interfaceElementType, engineObjectSymbol))
                {
                    elementType = interfaceElementType;
                    return true;
                }
            }
        }

        return false;
    }

    private static bool HasSuppressResourceClassGenerationAttribute(INamedTypeSymbol symbol, INamedTypeSymbol suppressAttribute)
    {
        // Check current class
        if (symbol.GetAttributes().Any(attr => SymbolEqualityComparer.Default.Equals(attr.AttributeClass, suppressAttribute)))
        {
            return true;
        }

        // Check base classes
        for (INamedTypeSymbol? current = symbol.BaseType; current is not null; current = current.BaseType)
        {
            if (current.GetAttributes().Any(attr => SymbolEqualityComparer.Default.Equals(attr.AttributeClass, suppressAttribute)))
            {
                return true;
            }
        }

        return false;
    }

    private static void Execute(SourceProductionContext context, Compilation compilation, ImmutableArray<ClassInfo> classes)
    {
        if (classes.IsDefaultOrEmpty)
        {
            return;
        }

        var processed = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);

        foreach (ClassInfo info in classes)
        {
            if (!processed.Add(info.Symbol))
            {
                continue;
            }

            if (!info.IsPartial)
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    s_missingPartialDiagnostic,
                    info.Symbol.Locations.FirstOrDefault(),
                    info.Symbol.ToDisplayString()));
                continue;
            }

            string source = GenerateSource(info);
            string hintName = GetHintName(info.Symbol);
            context.AddSource(hintName, source);
        }
    }

    private static string GenerateSource(ClassInfo info)
    {
        INamedTypeSymbol symbol = info.Symbol;
        string? namespaceName = symbol.ContainingNamespace is { IsGlobalNamespace: false } ns
            ? ns.ToDisplayString()
            : null;

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("#pragma warning disable CS8631");
        sb.AppendLine();

        if (namespaceName is not null)
        {
            sb.Append("namespace ").Append(namespaceName).AppendLine(";");
            sb.AppendLine();
        }

        string accessibility = GetAccessibility(symbol.DeclaredAccessibility);
        string typeParameterList = GetTypeParameterList(symbol);
        string constraintClauses = GetTypeConstraintClauses(symbol, string.Empty);

        sb.Append(accessibility).Append(" partial class ").Append(symbol.Name).Append(typeParameterList).AppendLine();
        if (!string.IsNullOrEmpty(constraintClauses))
        {
            sb.Append(constraintClauses);
        }
        sb.AppendLine("{");

        string indent = "    ";
        string currentTypeDisplay = symbol.ToDisplayString(s_typeDisplayFormat);

        AppendToResourceMethod(sb, indent, currentTypeDisplay, info);
        sb.AppendLine();
        AppendResourceClass(sb, indent, currentTypeDisplay, info);

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void AppendToResourceMethod(StringBuilder sb, string indent, string currentTypeDisplay, ClassInfo info)
    {
        string renderContextType = "global::Beutl.Graphics.Rendering.RenderContext";
        string engineObjectType = "global::Beutl.Engine.EngineObject";
        string baseResourceType = $"{engineObjectType}.Resource";

        if (info.Symbol.IsAbstract)
        {
            sb.Append(indent)
                .AppendLine($"public abstract override {currentTypeDisplay}.Resource ToResource({renderContextType} context);");
        }
        else
        {
            sb.Append(indent)
                .AppendLine($"public override {currentTypeDisplay}.Resource ToResource({renderContextType} context)");
            sb.Append(indent).AppendLine("{");
            sb.Append(indent).AppendLine($"    var resource = new {currentTypeDisplay}.Resource();");
            sb.Append(indent).AppendLine("    bool updateOnly = true;");
            sb.Append(indent).AppendLine("    resource.Update(this, context, ref updateOnly);");
            sb.Append(indent).AppendLine($"    return resource;");
            sb.Append(indent).AppendLine("}");
        }
    }

    private static void AppendResourceClass(StringBuilder sb, string indent, string currentTypeDisplay, ClassInfo info)
    {
        string renderContextType = "global::Beutl.Graphics.Rendering.RenderContext";
        string engineObjectType = "global::Beutl.Engine.EngineObject";

        if (info.Symbol.IsAbstract)
        {
            sb.Append(indent).Append("public new abstract partial class Resource");
        }
        else
        {
            sb.Append(indent).Append("public new partial class Resource");
        }

        if (info.BaseResourceOwner is INamedTypeSymbol baseOwner)
        {
            sb.Append($" : {baseOwner.ToDisplayString(s_typeDisplayFormat)}.Resource");
        }
        else
        {
            sb.Append($" : {engineObjectType}.Resource");
        }

        sb.AppendLine();
        sb.Append(indent).AppendLine("{");

        string innerIndent = indent + "    ";

        foreach (ValuePropertyInfo property in info.ValueProperties)
        {
            string fieldName = ToFieldName(property.Name);
            string valueTypeDisplay = property.ValueType.ToDisplayString(s_typeDisplayFormat);
            sb.Append(innerIndent).AppendLine($"private {valueTypeDisplay} {fieldName};");
            sb.AppendLine();
        }

        foreach (ObjectPropertyInfo property in info.ObjectProperties)
        {
            string fieldName = ToFieldName(property.Name);
            string resourceType = GetResourceTypeName(property.ValueType);
            sb.Append(innerIndent).AppendLine($"private {resourceType} {fieldName};");
            sb.AppendLine();
        }

        foreach (ListPropertyInfo property in info.ListProperties)
        {
            string fieldName = ToFieldName(property.Name);
            string resourceType = GetResourceTypeName(property.ElementType);
            sb.Append(innerIndent)
                .AppendLine($"private global::System.Collections.Generic.List<{resourceType}> {fieldName} = [];");
            sb.AppendLine();
        }

        foreach (ValuePropertyInfo property in info.ValueProperties)
        {
            string fieldName = ToFieldName(property.Name);
            string valueTypeDisplay = property.ValueType.ToDisplayString(s_typeDisplayFormat);
            sb.Append(innerIndent).AppendLine($"public {valueTypeDisplay} {property.Name}");
            sb.Append(innerIndent).AppendLine("{");
            sb.Append(innerIndent).AppendLine($"    get => {fieldName};");
            sb.Append(innerIndent).AppendLine($"    set => {fieldName} = value;");
            sb.Append(innerIndent).AppendLine("}");
            sb.AppendLine();
        }

        foreach (ObjectPropertyInfo property in info.ObjectProperties)
        {
            string fieldName = ToFieldName(property.Name);
            string resourceType = GetResourceTypeName(property.ValueType);
            sb.Append(innerIndent).AppendLine($"public {resourceType} {property.Name}");
            sb.Append(innerIndent).AppendLine("{");
            sb.Append(innerIndent).AppendLine($"    get => {fieldName};");
            sb.Append(innerIndent).AppendLine($"    set => {fieldName} = value;");
            sb.Append(innerIndent).AppendLine("}");
            sb.AppendLine();
        }

        foreach (ListPropertyInfo property in info.ListProperties)
        {
            string fieldName = ToFieldName(property.Name);
            string resourceType = GetResourceTypeName(property.ElementType);
            sb.Append(innerIndent).AppendLine($"public global::System.Collections.Generic.List<{resourceType}> {property.Name}");
            sb.Append(innerIndent).AppendLine("{");
            sb.Append(innerIndent).AppendLine($"    get => {fieldName};");
            sb.Append(innerIndent).AppendLine($"    set => {fieldName} = value;");
            sb.Append(innerIndent).AppendLine("}");
            sb.AppendLine();
        }

        sb.Append(innerIndent).AppendLine($"public new {currentTypeDisplay} GetOriginal()");
        sb.Append(innerIndent).AppendLine("{");
        sb.Append(innerIndent).AppendLine($"    return ({currentTypeDisplay})base.GetOriginal();");
        sb.Append(innerIndent).AppendLine("}");

        bool hasAdditionalMembers = info.ValueProperties.Length > 0
            || info.ObjectProperties.Length > 0
            || info.ListProperties.Length > 0;

        sb.Append(innerIndent)
            .AppendLine(
                $"partial void PreUpdate({currentTypeDisplay} obj, {renderContextType} context);");
        sb.Append(innerIndent)
            .AppendLine(
                $"partial void PostUpdate({currentTypeDisplay} obj, {renderContextType} context);");
        sb.Append(innerIndent)
            .AppendLine(
                $"public override void Update({engineObjectType} obj, {renderContextType} context, ref bool updateOnly)");
        sb.Append(innerIndent).AppendLine("{");

        sb.Append(innerIndent).AppendLine($"    this.PreUpdate(({currentTypeDisplay})obj, context);");
        sb.Append(innerIndent).AppendLine("    base.Update(obj, context, ref updateOnly);");

        bool wroteSection = false;

        if (hasAdditionalMembers)
        {
            sb.AppendLine();

            if (info.ValueProperties.Length > 0)
            {
                foreach (ValuePropertyInfo property in info.ValueProperties)
                {
                    string fieldName = ToFieldName(property.Name);
                    sb.Append(innerIndent)
                        .AppendLine(
                            $"    CompareAndUpdate(context, (({currentTypeDisplay})obj).{property.Name}, ref {fieldName}, ref updateOnly);");
                }

                wroteSection = true;
            }

            if (info.ListProperties.Length > 0)
            {
                if (wroteSection)
                {
                    sb.AppendLine();
                }

                int listIndex = 0;
                foreach (ListPropertyInfo property in info.ListProperties)
                {
                    if (listIndex > 0)
                    {
                        sb.AppendLine();
                    }

                    listIndex++;
                    string fieldName = ToFieldName(property.Name);
                    sb.Append(innerIndent)
                        .AppendLine(
                            $"    CompareAndUpdateList(context, (({currentTypeDisplay})obj).{property.Name}, ref {fieldName}, ref updateOnly);");
                }

                wroteSection = true;
            }

            if (info.ObjectProperties.Length > 0)
            {
                if (wroteSection)
                {
                    sb.AppendLine();
                }

                int objectIndex = 0;
                foreach (ObjectPropertyInfo property in info.ObjectProperties)
                {
                    if (objectIndex > 0)
                    {
                        sb.AppendLine();
                    }

                    objectIndex++;
                    string fieldName = ToFieldName(property.Name);
                    sb.Append(innerIndent)
                        .AppendLine(
                            $"    CompareAndUpdateObject(context, (({currentTypeDisplay})obj).{property.Name}, ref {fieldName}, ref updateOnly);");
                }
            }
        }

        sb.Append(innerIndent).AppendLine($"    this.PostUpdate(({currentTypeDisplay})obj, context);");
        sb.Append(innerIndent).AppendLine("}");
        sb.AppendLine();

        sb.Append(indent).AppendLine("}");
    }

    private static string GetAccessibility(Accessibility accessibility)
    {
        return accessibility switch
        {
            Accessibility.Public => "public",
            Accessibility.Internal => "internal",
            Accessibility.Protected => "protected",
            Accessibility.Private => "private",
            Accessibility.ProtectedOrInternal => "protected internal",
            Accessibility.ProtectedAndInternal => "private protected",
            _ => "internal",
        };
    }

    private static string GetTypeParameterList(INamedTypeSymbol symbol)
    {
        if (symbol.TypeParameters.Length == 0)
        {
            return string.Empty;
        }

        var builder = new StringBuilder();
        builder.Append('<');
        for (int i = 0; i < symbol.TypeParameters.Length; i++)
        {
            if (i > 0)
            {
                builder.Append(", ");
            }

            builder.Append(symbol.TypeParameters[i].Name);
        }

        builder.Append('>');
        return builder.ToString();
    }

    private static string GetTypeConstraintClauses(INamedTypeSymbol symbol, string indent)
    {
        if (symbol.TypeParameters.Length == 0)
        {
            return string.Empty;
        }

        var sb = new StringBuilder();
        foreach (ITypeParameterSymbol typeParameter in symbol.TypeParameters)
        {
            var constraints = new List<string>();
            foreach (ITypeSymbol constraintType in typeParameter.ConstraintTypes)
            {
                constraints.Add(constraintType.ToDisplayString(s_typeDisplayFormat));
            }

            if (typeParameter.HasUnmanagedTypeConstraint)
            {
                constraints.Add("unmanaged");
            }
            else if (typeParameter.HasValueTypeConstraint)
            {
                constraints.Add("struct");
            }
            else if (typeParameter.HasReferenceTypeConstraint)
            {
                constraints.Add("class");
            }

            if (typeParameter.HasNotNullConstraint)
            {
                constraints.Add("notnull");
            }

            if (typeParameter.HasConstructorConstraint)
            {
                constraints.Add("new()");
            }

            if (constraints.Count == 0)
            {
                continue;
            }

            sb.Append(indent).Append("    where ").Append(typeParameter.Name).Append(" : ");
            for (int i = 0; i < constraints.Count; i++)
            {
                if (i > 0)
                {
                    sb.Append(", ");
                }

                sb.Append(constraints[i]);
            }

            sb.AppendLine();
        }

        return sb.ToString();
    }

    private static string ToFieldName(string propertyName)
    {
        if (string.IsNullOrEmpty(propertyName))
        {
            return "_value";
        }

        if (propertyName.Length == 1)
        {
            return "_" + propertyName.ToLowerInvariant();
        }

        return "_" + char.ToLowerInvariant(propertyName[0]) + propertyName.Substring(1);
    }

    private static string GetResourceTypeName(INamedTypeSymbol symbol)
    {
        var name = symbol.ToDisplayString(s_typeDisplayFormat);
        if (name.EndsWith("?"))
        {
            return name.Substring(0, name.Length - 1) + ".Resource?";
        }
        return symbol.ToDisplayString(s_typeDisplayFormat) + ".Resource";
    }

    private static string GetHintName(INamedTypeSymbol symbol)
    {
        string name = symbol.ToDisplayString(SymbolDisplayFormat.CSharpErrorMessageFormat);
        var sb = new StringBuilder(name.Length + 32);
        foreach (char c in name)
        {
            sb.Append(c switch
            {
                '<' or '>' or ',' or '.' or ' ' or ':' => '_',
                _ => c,
            });
        }

        sb.Append("_Resource.g.cs");
        return sb.ToString();
    }

    private readonly record struct ClassInfo(
        INamedTypeSymbol Symbol,
        bool IsPartial,
        INamedTypeSymbol? BaseResourceOwner,
        ImmutableArray<ValuePropertyInfo> ValueProperties,
        ImmutableArray<ObjectPropertyInfo> ObjectProperties,
        ImmutableArray<ListPropertyInfo> ListProperties);

    private readonly record struct ValuePropertyInfo(string Name, ITypeSymbol ValueType);

    private readonly record struct ObjectPropertyInfo(string Name, INamedTypeSymbol ValueType);

    private readonly record struct ListPropertyInfo(string Name, INamedTypeSymbol ElementType);
}
